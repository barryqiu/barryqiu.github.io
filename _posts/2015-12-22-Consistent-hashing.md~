---
title: 一致性哈希
layout: post
categories: 大数据和高并发
---

# 1 背景

现在的高并发网站，都离不开缓存系统，通常情况下，大部分的请求都会直接打到缓存系统，从而提高响应速度并减少后端DB或者二级缓存的压力。缓存系统通常都是以一个集群的形式存在的，内容被缓存在若干台缓存服务器上，例如我们有 \\(n \\)台缓存服务器，那么通常的做法是对被缓存的对象 \\(O\\) 进行哈希操作然后再对 \\(n\\) 求余，即 $$ hash(O)\ Mod\ n $$。但是这种缓存负载分发方法有个较大的弊端，就是当我们需要增加或者减少缓存服务器的时候，所有的缓存内容的hash值都会改变，因而会发生大面积的数据交换，造成系统负载上升，响应速度下降。因此我们就需要一种特殊的哈希算法来避免这种问题。这种算法要求当增加一台缓存服务器的时候，新的服务器尽量分担其他所有服务器的缓存资源，当减少一台服务器的时候，其他所有服务器也可以尽量分担存储它的缓存资源，在这两种情况下其他服务器之间不需要大量的数据交换。为了实现这种需求，MIT的KAGER及其合作者提出了一种被称为一致性哈希的算法（这里其实表述的有点问题，最初一致性哈希算法并非是为了解决缓存系统的增加减少服务器问题的，它最初被设计来用户易变的分布式Web服务中的系统添加或者删除节点的问题）

# 2 主要原理
一致性哈希的主要原理是一种环状的Hash空间，然后将待存储对象和可以存储服务的机器都hash到这一个环状的hash空间中（这里和传统的hash负载的主要区别就是，传统的hash仅仅对数据进行hash操作），然后将待存储对象沿着圆环逆时针（顺时针）滑动直到遇到一个机器节点，然后就将该对象存储到这个机器节点中。当删除某一台机器时，就将该机器上的所有数据对象都按照圆环移动到下一台机器，当添加一台机器到圆环上时，这个点的下一台机器就将自己存储的对象中映射空间在被添加的机器节点之前的数据移动到被添加的机器上去。这样一来不管时新增或者删除机器都不会对现有的缓存系统造成很大的影响。

# 3 举例说明
假设Hash空间为0-99，系统中有A，B，C三台机器，其中:

$$hash(A)=33$$,
$$hash(B)=70$$,
$$hash(C)=2$$,

然后有a,b,c,d四个数据，有：

$$hash(a)=15$$,
$$hash(b)=56$$,
$$hash(c)=73$$,
$$hash(d)=86$$,

那么根×据上面的规则，按照递增的方向去则数据分布情况如下：

A=(a),
B=(b),
C=(c,d)

此时如果新增了一个D服务器，且

$$hash(D)=90$$,

那么D的下一个节点C中比D小的节点都会移动到D中，则分布情况就变成了：

A=(a),
B=(b),
C=()
D=(c,d)

此时A服务器失效了，那么A中的数据将会转移到下一个服务器节点中，数据分布情况就会变成下面这种情况：

B=(a,b),
C=()
D=(c,d)

# 4 一致性哈希的特点

* 冗余少
* 负载均衡
* 过度平滑
* 存储均衡
* 关键词单调




