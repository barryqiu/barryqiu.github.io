---
title: IO模型学习
layout: post
categories: 大数据和高并发
---

# 1 概述

网络IO的本质就是socket流的读取，通常一次IO读操作会涉及到两个对象和两个阶段。

两个对象分别是：

* 用户进程（线程）Process（Thread）
* 内核对象 Kernel

两个阶段：

- 等待流数据准备（wating for the data to be ready）;
- 从内核向进程复制数据（copying the data from the kernel to the process）;

对于socket流而已：

- 第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。
- 第二步把数据从内核缓冲区复制到应用进程缓冲区。

以快递员送快递来说明这个过程就是：

- 快递员先会把快递送到门卫大爷那里（等待流数据准备）
- 门卫大爷再把快递分给小区的各家各户（从内核向进程复制数据）

过Richard Stevens的经典书籍UNP，书中给出了5种IO模型：

- blocking IO - 阻塞IO
- nonblocking IO - 非阻塞IO
- IO multiplexing - IO多路复用
- signal driven IO - 信号驱动IO
- asynchronous IO - 异步IO

这五种IO模型，前面四种是同步IO，第五种是异步IO，下面我们以快递员送快递为例子讲解这五种IO模型。

# 2 详细分析

## 2.1 阻塞IO

最流行的I/O模型是阻塞I/O模型，在这种模型下，两个阶段的操作都是阻塞的。在数据没准备好的时候，process原地等待kernel准备数据。kernel准备好数据后，process继续等待kernel将数据copy到自己的buffer。在kernel完成数据的copy后process才会从recvfrom系统调用中返回。

你在网上下完单，然后就什么也不干在那里等快递，先等快递到大爷那，再等待大爷给你分快递。

## 2.2 非阻塞IO

进程把一个套接口设置成非阻塞是在通知内核：当所请求的I/O操作不能满足要求时候，不把本进程投入睡眠，而是返回一个错误。也就是说当数据没有到达时并不等待，而是以一个错误返回非阻塞IOrecvfrom操作的第一个阶段是不会block等待的，如果kernel数据还没准备好，那么recvfrom会立刻返回一个EWOULDBLOCK错误。当kernel准备好数据后，进入处理的第二阶段的时候，process会等待kernel将数据copy到自己的buffer，在kernel完成数据的copy后process才会从recvfrom系统调用中返回。

你在网上下完单，然后每隔1分钟打个电话给门卫大爷问问他有没有你的快递，如果没有就挂电话干点别的，如果有就停下所有事情等大爷把快递送上门。

## 2.3 多路复用IO

IO多路复用，就是我们熟知的select、poll、epoll模型。在IO多路复用的时候，process在两个处理阶段都是block住等待的。初看好像IO多路复用没什么用，其实select、poll、epoll的优势在于可以以较少的代价来同时监听处理多个IO。

linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select;这样select/poll可以帮我们侦测许多fd是否就绪。但是select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限。linux还提供了一个epoll系统调用，epoll是基于事件驱动方式，而不是顺序扫描,当有fd就绪时，立即回调函数rollback；

现在是双11，你买了很多东西，你希望可以哪个快递先到就先拆那个包裹，但是如果采用上面的两种方法都只能等待一个包裹，如果希望可以不忙等一个，可以有两种方案：

- 你发动家人一起来收快递，每个人负责一件，这就是多进程或者多线程
- 让快递员把快递交给门卫大爷让后让门卫大爷通知大家来取快递

这个时候分两种情况：

- 门卫大爷不知道这个快递你的哪个快递，只能挨个问是不是你的A快递，B快递（不同的快递可能需要不同的方式来取，推车等等），这就是select IO模型
- 你把你的快递在门卫大爷那儿登记了快递描述，门卫大爷直接根据这个映射表去通知你取快递，这就是EPOLL或者Kqueue模型

## 2.4 信号驱动异步模型

我们也可以用信号，让内核在描述字就绪时发送SIGIO信号通知我们。我们称这种模型为信号驱动I/O（signal-driven I/O）。

## 2.5 异步I/O模型

异步IO要求process在recvfrom操作的两个处理阶段上都不能等待，也就是process调用recvfrom后立刻返回，kernel自行去准备好数据并将数据从kernel的buffer中copy到process的buffer在通知process读操作完成了，然后process在去处理。遗憾的是，linux的网络IO中是不存在异步IO的，linux的网络IO处理的第二阶段总是阻塞等待数据copy完成的。真正意义上的网络异步IO是Windows下的IOCP（IO完成端口）模型。很多时候，我们比较容易混淆non-blocking IO和asynchronous IO，认为是一样的。但是通过上图，几种IO模型的比较，会发现non-blocking IO和asynchronous IO的区别还是很明显的，non-blocking IO仅仅要求处理的第一阶段不block即可，而asynchronous IO要求两个阶段都不能block住。

你在网上下完单之后，不用一直等快递，可以干别的事情，比如做家务之类的，快递先是送到门卫大爷那儿，然后门卫大爷给你送过来，这两个过程对你来说都是透明的，只需要等门卫大爷敲门告诉你快递到了即可。

## 3 总结
下图展示了五种IO模型的区别：

![](http://7xj536.com1.z0.glb.clouddn.com/blog/IOmodel.png)